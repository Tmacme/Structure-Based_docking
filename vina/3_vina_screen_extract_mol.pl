#!/usr/bin/perl -w
use strict;

############################################################################
#
#	Peter M.U. Ung	@ MSSM
#
#	v1.0	- 13.10.24
#	v2.0	- 13.11.04 - add properties to SDF file for RDKit work
#	v3.0	- 13.11.20 - add the VINA tag to the name for future process
#
#	Extract the structure/SMILES of AutoDock .pdbqt result with the 
#	correpsonding ZINC ID.
#	Takes the Top list generated by vina_screen_get_top.py
#	Uses OBabel for conversion.
#	Handles .smi, .mol2, .sdf, .mol format.
#	SDF format is peferred for RDKit operation (default)
#
#	Required:	vina_screen_preprocess.py
#			vina_screen_get_top.py
#
############################################################################


die "\n    Usage: x.pl [dir with ZINC ref: txt] [top result list: txt]\n
           [output format] [result filename prefix] [ref PDB: pdb]\n            ## SDF format is preferred for RDKit operation\n       -- Do it at the same level as the directories with Vina docked results --\n\n"
  unless @ARGV == 5;

my @file = `ls $ARGV[0]/*.txt`;
die "\n    Warning: ZINC reference files are zipped\n\n"
  if !@file;

my $format = 'sdf';

## Read in the reference files with ZINC ID
my %zinc;
foreach my $file (@file) {

  open ZINC, "< $file";
  while (<ZINC>) {
    chomp;
    my @line = split;
    my $ZINC = $line[2];
    my @mol  = split /\./, $line[0];
    my $ADid = $mol[0].".".$mol[1].".".$mol[3];

    $zinc{$ADid} = $ZINC;
  }
  print "\n  ## Finished loading $file\n\n";
  close ZINC;
}

## Read in the Top_Vina list
my @data = ();
open IN, "< $ARGV[1]";
while (<IN>) {
  next if /##/;
  last if /^\n/;
  my @line = split;
  my @fold = split /\//, $line[1];
  my @ADid = split /\./, $fold[1];

  my $scr  = $line[2];
  my $id   = $fold[0].".".$ADid[2];
             # (rank,     location, folder,   ADid,     ZINC      , score )
  push @data, [($line[0], $line[1], $fold[0], $ADid[2], $zinc{$id}, $scr)];
}
close IN;

## 
my $i = 1;
open OUT, "> $ARGV[3]";
my @tmp_sdf = ();	# lines of temp file, vina.$i.sdf, for PyMOL import

foreach my $data (@data) {
  ## Output Top_Vina as SMILES file
  if ($format eq "smi") {
    my @smi = `obabel -ipdbqt $ARGV[0]$data->[1] -o$format --canonical -l 1`;
    my @check = split /\t/, $smi[0];

#    die "\n $check[1] != $data->[2].$data->[3]\n\n" if $check[1] !~ /$data->[2]\.$data->[3]/;
#    $smi[0] =~ s/\.pdbqt/ $data->[4]/;
    print OUT "$smi[0]\t$data->[4]\n";
  }
  ## Output Top_Vina as 3D file
  if ($format =~ /mol2|mol|sdf/) {
    my @str = `obabel -ipdbqt $data->[1] -o$ARGV[2] -l 1 --add formula MW logP TPSA`;

    open TMP, "> Vina.$i.$ARGV[2]";
    foreach (@str) {
           # ZincID::Rank::Score::VINA
      $_ = "$data->[4]::$data->[0]::$data->[5]::VINA\n" if /\.pdbqt/;
      if (/<REMARK>/ and $format eq 'sdf') {
        print OUT ">  <ZINC>\n$data->[4]\n\n>  <VINARANK>\n";
        print OUT "$data->[0]\n\n>  <VINA>\n$data->[5]\n\n";
      }
      print OUT;
      print TMP;
    }
    close TMP;

    my $x= sprintf "load Vina.$i.$ARGV[2]\n";# Load SDF file input PyMOL script
    push @tmp_sdf, $x;

  }
  print "$i  - "; $i++;
}

my $pdb = `basename $ARGV[4] .pdb`;
my $sdf = `basename $ARGV[3] .sdf`;
chomp($pdb); chomp($sdf);
open PML, "> temp.pml";
print PML "load $ARGV[4]\n";	# Load ref PDB into PyMOL
print PML "load $ARGV[3]\n";	# Load concatenated ligand SDF into PyMOL
print PML "distance HB, $pdb, $sdf, mode=2\n";
foreach (@tmp_sdf) { print PML; }   # Load individual ligand SDF into PyMOL
print PML "hide lines, poly\n";
print PML "set line_width, 4\n";
print PML "show cartoon, poly\n";
print PML "set transparency, 0.2\n";
print PML "show surface, poly\n";
print PML "color white, poly\n";
print PML "center poly\n zoom poly\n";
print PML "save $ARGV[3].pse\nquit\n";
close PML;

system("pymol -c temp.pml");

system("rm ./Vina.*.sdf");
system("rm ./temp.pml");
